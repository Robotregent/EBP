\section{Technische Realisierung}

\subsection{Architektur}
Das Projekt ist in folgende Module aufgeteilt:
\begin{itemize}
	\item EBP-Client - Grafisches Datenbankfrontend für den alltäglichen Gebrauch
	\item AdminDialog - Grafisches Datenbank-Administrationswerkzeug
	\item libEBPdb - Stellt Fachklassen und Persistenzfunktionen als Bibliothek zur Verfügung
	\item Unit-Tests - Automatisierte Tests der Bibliothek
\end{itemize}

\newpage

\subsection{Qt als Grafikbibliothek}

\newpage

\subsection{Buildsystem}
Da das Projekt \textit{Qt} als einen zentralen Bestandteil verwendet, ist es naheliegend das \textit{Qt}-eigene Buildsystem \textit{QMake} einzusetzen. Insbesondere die Verwendung von \textit{QMake} innerhalb des \textit{QtCreator}s kann die Entwicklung einfacher Anwendungen erleichtern.\\
Eine bedeutende Schwierigkeit von \textit{QMake} ist es jedoch, komplexere Build-Prozesse zu automatisieren, wie beispielsweise die Integration des verwendeten \textit{ORM}s in den Build-Vorgang der Persistenzschicht.\\
Daher wurde in diesem Projekt ein zweigleisiges Buildsystem eingesetzt:\\
Zum einen lassen sich die GUI-Anwendungen weiterhin mit \textit{QMake} erstellen. Zum anderen kann das komplette Projekt samt Bibliothek der Persistenzschicht mit \textit{CMake} kompiliert werden.\\

\newpage

\subsection{Persistenzschicht mit ODB (libEBPdb)}

\subsubsection{Object-Relational-Mapping (ORM)}
Um die Daten einer relationellen Datenbank auf Objekte innerhalb einer Programmiersprache abzubilden gibt es prinzipiell zwei Ansätze.
Entweder wird der Code der die Eigenschaften eines Objekts aus der Datenbank liest und schreibt manuell implementiert, oder aber es wird ein Mechanismus eingesetzt, der automatisiert Variablen eines Objekts den Feldern einer Datenbank zuordnet (Object-Relational-Mapping).\\
Das Einsetzen eines solchen Mappers hat den Vorteil, dass der sich oft wiederholende Code zum Laden und Speichern der Daten von und in die Datenbank reduziert werden kann. Dies führt zu wartbarerem Code, der bei Änderungen an der Datenbankstruktur schneller und fehlerfreier anpassbar ist.

\subsubsection{Auswahl des Verwendeten Mappers}
Das verwendete Qt4-Toolkit enthält zwar eine plattformunabhängige Schnittstelle für Datenbanken (QtSql), jedoch hat diese keine ORM Funktion.
Folgende ORM-Systeme wurden in Betracht gezogen\\
\url{http://en.wikipedia.org/wiki/List_of_object-relational_mapping_software}:
\begin{itemize}
	\item LiteSQL - Datenbankschema wird mit XML Dateien beschrieben
	\item ODB - Datenbankschema wird aus den C++ Klassen generiert
	\item QxOrm - Benutzt QtSql; Unter Umständen müssen direkte Aufrufe von QtSql erfolgen. \cite{QxOrm_Tutorial}
\end{itemize}
Alle Systeme bieten eine Qt Integration, die die Schnittstelle zwischen GUI und Persistenzschicht vereinfachen.
Ebenso unterstützen alle Systeme mehrere Datenbankbackends.
Letztendlich fiel die Entscheidung auf ODB, da diese Bibliothek (unter anderem durch Caching) die beste Performance verspricht.
Außerdem lassen sich Klassen mit geringem Aufwand persistent machen.

\newpage

\subsubsection{Code-Generierung}
Kern des verwendeten Object-Relational-Mappers ODB ist ein spezieller Precompiler, der auf bestimmte Precompiler-Pragmas reagiert.
Durch das Markieren einer Klassendefinition mit einer Pragma-Direktive können persistente Objekte der Klasse erstellt werden:\\
\begin{lstlisting}
#pragma db object
class Mitarbeiter { ... }
\end{lstlisting}
Der ODB-Compiler generiert daraufhin Code, der das gegebene Objekt auf eine Datenbankstruktur abbilden kann. Des weiteren wird auch die Datenbankstruktur in Form von SQL-Dateien generiert, die direkt an die verwendete Datenbank weitergereicht werden können um alle zur Laufzeit benötigten Tabellen zu erstellen. Auf diese Weise wird ebenso sichergestellt, dass Datenbank und Anwendung stets die selbe Struktur verwenden.\\
\begin{figure*}[htp!]
	\begin{center}
		\includegraphics[width=0.4\textwidth]{odb-flow}
	\end{center}
	\caption{ODB Toolchain \cite{ODB_Manual}}
	\label{ODB-Flow}
\end{figure*}

\newpage

\subsubsection{Datenbankunabhängigkeit}
Durch die zusätzliche Abstraktionsschicht ist es einfacher die bestehende Persistenzschicht auf ein neues Datenbanksystem zu portieren.\\
Die umgesetzte Lösung ist weitestgehend frei von datenbankspezifischen Aufrufen, und benutzt ausschließlich die Schnittstelle des eingesetzten Object-Relational-Mappers.
Lediglich das User-Management, um ``Mitarbeiter`` auf Datenbankbenutzer abzubilden verwendet Datenbankspezifische SQL-Kommandos, die über ODB abgewickelt werden.

\subsubsection{Integration in das Buildsystem}
Um das Buildsystem (CMake) automatisch bei Veränderungen des Quellcodes alle für ODB benötigten Dateien generieren zu lassen, wird im Buildscript wie folgt vorgegangen:
\begin{enumerate}
\item Suchen aller Dateien die ODB spezifische Pragma-Definitionen beinhalten.
\item Erstellen einer Vorschrift um für jede so gefundene Datei den ODB-Compiler aufzurufen.
	Dabei werden auch die Abhängigkeiten der generierten Dateien korrekt in das Buildsystem eingefügt, so dass diese nur neu generiert werden, wenn tatsächlich Änderungen an der jeweiligen Eingangsdatei oder deren Abhängigkeiten vorhanden sind.
\end{enumerate}
Der entsprechende Auszug aus dem CMake Buildscript:\\
\lstset{language=clean}
Jeder zum Projekt gehörende C++ Header wird eingelesen und nach ODB-Pragma-Definitionen durchsucht:
\begin{lstlisting}
foreach( header ${EBPdb_headers} )
	file( READ ${header} headercontent )
	if( "${headercontent}" MATCHES "#pragma[ \t]+db[ \t]+object" )
\end{lstlisting}
Für jede gefundene Datei wird die generierte ODB-Datei zu den zu kompilierenden Quelldateien hinzugefügt:
\begin{lstlisting}
		get_filename_component( headerbase ${header} NAME_WE )
		set( EBPdb_sources ${EBPdb_sources} ${headerbase}-odb.cxx )
\end{lstlisting}
Damit der ODB-Precompiler den Quellcode korrekt parsen kann, müssen sämtliche verwendeten Include-Verzeichnisse bei dem Aufruf des Precompilers angegeben werden. Die Projekteinstellungen werden hierfür übernommen:
\begin{lstlisting}
		get_directory_property( odbincludes INCLUDE_DIRECTORIES )
		foreach( includedir ${odbincludes} )
			set( odbincludeargs ${odbincludeargs} -I${includedir} )
		endforeach( includedir )
\end{lstlisting}
Eine Regel zum Ausführen des Precompilers der der die Quellcode-Datei generiert wird erstellt (gleichzeitig werden auch alle weiteren benötigten Dateien erzeugt):
\begin{lstlisting}
		add_custom_command( OUTPUT ${headerbase}-odb.cxx ${headerbase}-odb.hxx ${headerbase}-odb.ixx ${headerbase}.sql
			COMMAND odb ${odbincludeargs} --database mysql --profile qt --generate-query --generate-schema ${header}
			DEPENDS ${header} )
	endif( "${headercontent}" MATCHES "#pragma[ \t]+db[ \t]+object" )
endforeach( header )
\end{lstlisting}


\newpage

\subsubsection{Datenbankschema}
\begin{figure*}[htp!]
	\begin{center}
		\includegraphics[width=0.93\textwidth]{scheme}
	\end{center}
	\caption{Datenbankschema als ER Diagramm}
	\label{ERDiagram}
\end{figure*}

\subsubsection{Abstraktion der Schnittstelle}
\lstset{language=c++}
Zweck der Bibliothek ist es die internen Abläufe des ORM Systems zu verbergen, und der Anwendung eine einfache, objektorientierte Schnittstelle zur Verfügung zu stellen.\\
Voraussetzung zur Verwendung der Bibliothek ist eine funktionierende Verbindung zur Datenbank:\\
\begin{lstlisting}
QSharedPointer<ebp::connection> connection =
	QSharedPointer<ebp::connection>
	(
		new ebp::connection( "LoginName", "DatenbankName", "localhost", 3306)
	);
connection->establish( "PasswortDesBenutzers" );
QSharedPointer<Mitarbeiter> mitarbeiter = connection->mitarbeiter();
\end{lstlisting}
Sollen neue Mitarbeiter auf die Datenbank zugreifen, kann mit\\
\begin{lstlisting}
QSharedPointer<ebp::Mitarbeiter> neuerMitarbeiter =
	QSharedPointer<ebp::Mitarbeiter>
	(
		new ebp::Mitarbeiter( "LoginName", ebp::Mitarbeiter::WohngruppenRecht, "Name" )
	);
neuerMitarbeiter->create( connection, "PasswortDesNeuenMitarbeiters" );
\end{lstlisting}
ein neuer Mitarbeiter in der Datenbank erstellen. Gleichzeitig wird auch ein neuer Datenbankbenutzer angelegt, der intern mit den Daten des Mitarbeiters verknüpft wird.
Der Datenbankbenutzer erhält dabei nur die Berechtigungen an den Datenbanktabellen, die er für seinen ''Rechtestatus`` benötigt.\\
\\
Analog zum Erstellen eines Mitarbeiters, lassen sich auch alle anderen Objekte der Bibliothek erzeugen:\\
\begin{lstlisting}
QSharedPointer<ebp::Bewohner> bewohner =
	QSharedPointer<ebp::Bewohner>
	(
		new ebp::Bewohner( 0 )
	);
bewohner->create( connection );
\end{lstlisting}
Veränderungen eines Objekts lassen sich mit der ''update``-Methode in der Datenbank sichern:\\
\begin{lstlisting}
bewohner->telefon( "0123456789" );
bewohner->update( connection );
\end{lstlisting}
Verknüpfungen lassen sich mit den jeweiligen ''link``-Methoden herstellen:\\
\begin{lstlisting}
ebp::Bewohner::linkBezugsbetreuer( bewohner,mitarbeiter);
ebp::Bewohner::linkWohngruppe( bewohner, wohngruppe);
bewohner->update( connection );
\end{lstlisting}
Dabei geht eine Verknüpfung immer von einer der Klassen aus - die andere ist das ''inverse`` Gegenstück.
Um die Verknüpfung persistent zu machen, muss immer die ''update``-Methode der Klasse verwendet werden, von der die Verknüpfung ausgeht.\\
Angelegte verknüpfungen lassen sich mit den verschiedenen ''load``-Methoden wieder laden:\\
\begin{lstlisting}
QList< QSharedPointer<ebp::Projekt> > projekte = bewohner->loadProjekte( connection );
\end{lstlisting}

\newpage

\subsection{Unit-Tests}
Unit-Tests, auch Komponententests genannt, sind sehr entwicklungsnahe Tests und sollen sicherstellen, dass die Erwartungen an eine Software
erfüllt werden können, indem Fehler vermieden werden.\\
''Das Testen von Software dient durch die Identifizierung von Defekten und deren anschließender Beseitigung zur Steigerung der Softwarequalität. Die
Testfälle sollen so gewählt werden, dass sie weitgehend der späteren Benutzung der Software entsprechen. Die nachgewiesene Qualität des Programms
während der Tests entspricht dann der zu erwartenden Qualität während der späteren Benutzung\cite[S. 11]{Softwaretests}.''\\
Bei Unit-Tests werden einzelne Programmmodule isoliert von einander getested. Dadurch sollen Einflüsse durch andere Softwarekomponenten
ausgeschlossen werden.

\newpage

\subsection{Eingesetzte Entwurfsmuster}
\subsubsection{Mediator Pattern - Der Text Transfer Agent}
Neben der Verwaltung von klienten- und wohngruppenspezifischen Daten ist die Überführung von Textstücken aus verschiedenen Teilen des
Dokumentationsprogramms die Hauptfunktion der \EBP. Diese Funktion wird im folgenden \textit{Text Transfer} genannt. \newline
Der \textit{Text Transfer} soll aus den Masken Bewohner$\rightarrow$Protokoll, Bewohner$\rightarrow$Projekt und Wohngruppe$\rightarrow$Gruppenbuch
erfolgen. Gespeichert werden die Textfragmente in den verschiedenen Feldern der Betreuungsplanung eines beliebigen Bewohners. Die Unterschiedlichkeit
der Quellen für die zu transferierende Textfragmente und die Variation an Zielfelder war die Schwierigkeit bei der Implementierung dieser
Funktionalität. Da die Anzahl an Objekten, die als Quelle dienen, im Programmverlauf stark variieren kann, muss der Lösungsansatz sehr flexibel
implementiert sein. Abbildung \ref{unstrukturiert} zeigt die Vielzahl an möglichen Kommunikationswegen zwischen den einzelnen Objekten.\\
\begin{figure*}[htp!]
	\includegraphics[width=0.8\textwidth]{unmediated}
	\caption{Kommunikationswege zwischen Objekten}
	\label{unstrukturiert}
\end{figure*}
Um nicht jeden Kommunikationsweg einzeln verwalten zu müssen, wurde der \textit{Text Transfer} in Form des Mediator Patterns entworfen. Den Zweck
eines Mediators definiert GAMMA wie folgt: \\
``Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from reffering to each other explicitly, 
and it lets you vary their interaction independently \cite[S. 273]{Entwurfsmuster}.''\\
\\
\textbf{Beteiligte Objekte\cite[S. 277]{Entwurfsmuster}:}
\begin{enumerate}
	\item Eine Instanz des TextTransferAgent als konkreter Mediator. Auf eine abstrakte Mediatorklasse wurde auf Grund des klar definierten Aufgabengebiets verzichtet.
	\begin{enumerate}
		\item Implementiert die Interaktion zwischen den verschiedenen Kollegen.
		\item Kennt alle zu verwaltenden Kollegenobjekte.
		\item Deklaration der Mediatorklasse TextTransferAgent:
		\begin{lstlisting}
class TextTransferAgent : public QFrame
{
    Q_OBJECT

public:
    explicit TextTransferAgent(QList<TextTransferInterface *>Interfaces,const SessionContext &context, QWidget *parent = 0);
    ~TextTransferAgent();
    void registerNewInterface(TextTransferInterface *newInterface);

private slots:
    void on_bewohnerBox_currentIndexChanged(int index);
    void on_losButton_clicked();
    void on_helpButton_clicked();

private:
    const SessionContext &_context;
    Ui::TextTransferAgent *ui;
    QSharedPointer< ebp::Bewohner > selectedBewohner;
    QList < QSharedPointer < ebp::Dokumentation > > dokus;
    QList<TextTransferInterface *> textInterfaces;
};
		\end{lstlisting}
	\end{enumerate}
	\item Beliebig viele Instanzen von Klassen, die das TextTransferInterface implementiert haben als Kollegen.
	\begin{enumerate}
		\item Jeder Kollege kennt das Mediatorobjekt.
		\item Möchte ein Kollege mit einem anderen kommunizieren, tut er dies über den Mediator.
		\item Die Kommunikation zwischen den Kollegen ist in dieser Implementierung unidirektional. Klassen, die das TextTransferInterface implementiert haben dienen stets 
			als Quelle für den Texttransfer. Als Ziel für den Texttransfer stehen dem Meditor über das aktive Bewohner Objekt alle Instanzen der Betreuungsplanung zur Verfügung.
		\item Deklaration des Kollegeninterfaces TextTransferInterface:
		\begin{lstlisting}
class TextTransferInterface
{
public:
    virtual TextTransferInformation getSelectedText()=0;
};
		\end{lstlisting}
	\end{enumerate}
\end{enumerate}
Abbildung \ref{strukturiert} zeigt die Kommunikationswege eines Texttransfers zwischen den einzelnen Objekten, koordiniert durch ein Mediatorobjekt. 
\begin{figure*}[htp!]
	\includegraphics[width=0.8\textwidth]{mediated}
	\caption{Kommunikationswege zwischen Objekten, koordiniert durch einen Mediator}
	\label{strukturiert}
\end{figure*}
\subsubsection{Observer Pattern - Signal Slot Konzept}
Ein klassisches Konzept zur Kommunikation zwischen Objekten stellen \textit{Events} und \textit{Eventhandler} dar. Dieses Konzept ist allerdings nicht typsicher und unflexibel, da es für ein \textit{Events} auch nur einen \textit{Eventhandler} geben kann\cite[S. 32]{Qt4}. Qt hingegen nutzt zur Kommunikation zwischen Objekten das \textit{Signal Slot Konzept}, das wie ein Observer Pattern aufgebaut ist. GAMMA beschreibt das Observer Pattern wie folgt: \\
"Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically\cite[S. 293]{Entwurfsmuster}."\\
Qt realisiert dies, indem Funktionen einer Klasse durch das Schlüsselwort \textit{Slot} gekennzeichnet werden können. Diese \textit{Slots} werden mit einem \textit{Signal} verbunden und sind damit als \textit{Observer} zu betrachten. Das \textit{Subject} ist ein Funktionsprototyp, der durch das Schlüsselwort \textit{Signal} gekennzeichnet wird. Dieser Prototyp wird nicht implementiert. GAMMA beschreibt diese Beziehung folgendermaßen:\\
''The Subject is the publisher of notifications. It sends out these notifications without having  to know who its observers are. Any number of observers can subscibe to receive notifications\cite[S. 294]{Entwurfsmuster}."\\
Verbunden wird ein \textit{Signal} mit einem \textit{Slot} durch den Aufruf der statischen Methode QObject::connect(). \textit{Signal} und \textit{Slot} müssen dabei die gleichen Argumente besitzen. Dadurch wird die Typsicherheit gewährleistet. Allerdings sind die Schlüsselworte \textit{Signal} und \textit{Slot} kein reines C++. Klassen die sich diesem Konzept bedienen müssen daher durch den \textit{Meta Object Compiler (MOC)} in Standard-konformes C++ verwandelt werden\cite[Vgl. S. 51]{Qt4}.
\EBP bedient sich dieses Konzepts an vielen Stellen. Der Anmeldevorgang soll hier als Beispiel dienen. Die Anmeldung an dem Client erfolgt auf einer Maske, die durch die Klasse LoginForm beschrieben wird. Diese Klasse definiert auch ein eigenes \textit{Signal} \textit{validLogin()}:
\begin{lstlisting}
class LoginForm : public QWidget
{
    ...
signals:
    void validLogin(QSharedPointer<ebp::Mitarbeiter> newMitarbeiter, QSharedPointer<ebp::connection> newConnection);
    ...
};
\end{lstlisting}
Die Klasse MainWindow definiert den dazu passenden \textit{Slot}, der nach einer erfolgreichen Anmeldung den Client initialisiert:
\begin{lstlisting}
class MainWindow : public QMainWindow
{
    ...
private slots:
    void validLogin(QSharedPointer<ebp::Mitarbeiter> newMitarbeiter, QSharedPointer<ebp::connection> newConnection);
    ...
};
\end{lstlisting}
Durch dieses Konzept der losen Kopplung könnten bei Bedarf weitere \textit{Slots} an ein erfolgreiches Anmelden angekoppelt werden, ohne auf den bereits bestehenden \textit{Slot} zum initialisieren des Clients Einfluss zu nehmen.
\subsubsection{Model/View Pattern - Datenvisualisierung}
Das Entwurfsmuster Model/View oder auch Model/View/Controller ist ein klassisches Entwurfsmuster der Softwareentwicklung und beschreibt, wie die Datenhaltung, die Visualisierung der Daten und die Interaktion mit dem Benutzer in verschiedenen Komponenten realisiert wird. Ziel dieses Entwurfsmusters ist es, flexiblen und wiederverwendbaren Programmcode zu entwickeln.
Das Framework Qt bietet die Variante des Model/View Entwurfsmusters an. Dabei werden Der Controller und der View in der selben Komponente realisiert. Dies vereinfacht die Handhabung, ermöglicht aber immernoch ein Trennen der Datenhaltung und der Visualisierung der Daten \cite[Vgl.]{QtModelView}.
Qt bietet Abstrakte Klassen für ein Table-, List- oder Treemodel an, um grundlegene Funtionalitäten für die entsprechenden Views vorzugeben. Sind diese Ansätze nicht flexibel genug, kann QAbstractItemModel implementiert werden. Um die Mitarbeiterobjekte in einem Tableview darstellen zu können, wurde ein einfaches Model mit Hilfe von QAbstractTableModel implementiert:
\begin{lstlisting}
class EmployeeTableModel : public QAbstractTableModel
{
    Q_OBJECT
    QList < QSharedPointer < ebp::Mitarbeiter > > EmployeeList;
public:
    explicit EmployeeTableModel(QList < QSharedPointer < ebp::Mitarbeiter> > employees, QObject *parent = 0);
    
    // Überschriebene Funktion. Liefert dem View die Anzahl an Zeilen    
    int rowCount(const QModelIndex &parent) const;

    // Überschriebene Funktion. Liefert dem View die Anzahl an Spalten
    int columnCount(const QModelIndex &parent) const;

    // Überschriebene Funktion. Liefert dem View die Daten.
    QVariant data(const QModelIndex &index, int role) const;

    // Überschriebene Funktion. Liefert dem View die Überschriften.
    QVariant headerData(int section, Qt::Orientation orientation, int role);
    QSharedPointer < ebp::Mitarbeiter> getMitarbeiter(int index);
    void addMitarbeiter(QSharedPointer<ebp::Mitarbeiter> newMitarbeiter);
};
\end{lstlisting}
Dieses Model kann in verschiedenen Tableviews verwendet werden. Die Views können sich stark von einander unterscheiden. Über die überschriebenen Funktionen von QAbstractTableModel wird sichergestellt, dass der View auf die richtigen Daten zugreift.
\newpage
